import React from 'react';
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import { MemoryRouter } from 'react-router-dom';
import Search from '../Search';
import { MoviesProvider } from '@/contexts/MoviesContext';
import { searchMovies } from '@/services/tmdb';
import type { Movie } from '@/types/movie';

jest.mock('@/services/tmdb');
jest.mock('@/hooks/use-debounce', () => ({
  useDebounce: (fn: (...args: unknown[]) => unknown) => fn,
}));

const mockSearchMovies = searchMovies as jest.MockedFunction<typeof searchMovies>;

const mockAddSearchTerm = jest.fn();
const mockRemoveSearchTerm = jest.fn();

jest.mock('@/contexts/MoviesContext', () => ({
  ...jest.requireActual('@/contexts/MoviesContext'),
  useMovies: () => ({
    favorites: [],
    addFavorite: jest.fn(),
    removeFavorite: jest.fn(),
    isFavorite: jest.fn(() => false),
    searchTerms: [],
    addSearchTerm: mockAddSearchTerm,
    removeSearchTerm: mockRemoveSearchTerm,
  }),
}));

const renderWithRoute = (route = '/search') => {
  return render(
    <MemoryRouter initialEntries={[route]}>
      <MoviesProvider>
        <Search />
      </MoviesProvider>
    </MemoryRouter>
  );
};

const makeMovie = (id: number, title: string): Movie => ({
  id,
  title,
  overview: 'Test overview',
  poster_path: '/test.jpg',
  backdrop_path: '/test-backdrop.jpg',
  release_date: '2023-01-01',
  vote_average: 7.5,
  vote_count: 1000,
  genre_ids: [1, 2, 3],
});

describe('Search component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should render search page with empty state when no query', () => {
    renderWithRoute('/search');
    
    expect(screen.getByText('Digite algo para buscar')).toBeInTheDocument();
    expect(screen.getByText('Use a barra de pesquisa acima para encontrar filmes')).toBeInTheDocument();
  });

  it('should display search results correctly', async () => {
    mockSearchMovies.mockResolvedValue({
      results: [makeMovie(1, 'Test Movie')],
      total_pages: 1,
      total_results: 1,
      page: 1,
    });
    
    renderWithRoute('/search?q=test');
    
    await waitFor(() => {
      expect(screen.getByText('Resultados da busca')).toBeInTheDocument();
    });
    
    expect(mockAddSearchTerm).toHaveBeenCalledWith('test');
  });

  it('should handle multiple search results', async () => {
    mockSearchMovies.mockResolvedValue({
      results: [makeMovie(1, 'Movie A'), makeMovie(2, 'Movie B')],
      total_pages: 1,
      total_results: 2,
      page: 1,
    });
    
    renderWithRoute('/search?q=movies');
    
    await waitFor(() => {
      expect(screen.getByText(/resultados encontrados/)).toBeInTheDocument();
    });
  });

  it('should display empty results when no movies found', async () => {
    mockSearchMovies.mockResolvedValue({
      results: [],
      total_pages: 1,
      total_results: 0,
      page: 1,
    });
    
    renderWithRoute('/search?q=nonexistent');
    
    await waitFor(() => {
      expect(screen.getByText('Nenhum filme encontrado')).toBeInTheDocument();
    });
  });
});
